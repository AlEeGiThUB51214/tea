\documentclass{acm_proc_article-sp}

\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{minted}
\usepackage{ebproof}

\hypersetup{unicode=true,
            pdftitle={Logic: An Idris port of Coq.Init.Logic},
            pdfauthor={Eric Bailey},
            pdfkeywords={logic; coq; idris},
            pdfborder={0 0 0},
            breaklinks=true}


\renewcommand{\iff}{\leftrightarrow}
\renewcommand{\implies}{\rightarrow}

\begin{document}

\title{Logic}
\subtitle{An Idris port of Coq.Init.Logic}

\numberofauthors{1}
\author{
    \alignauthor \affaddr{Eric Bailey}\\
\affaddr{https://github.com/yurrriq}\\
\email{eric@ericb.me}
  }

\date{}


\maketitle
\begin{abstract}
Here I present an Idris port of the
\href{https://coq.inria.fr/library/Coq.Init.Logic.html}{\mintinline[]{idris}{Coq.Init.Logic}}
module from the Coq standard library.
\end{abstract}

% % A category with the (minimum) three required fields
% \category{H.4}{Information Systems Applications}{Miscellaneous}
% %A category including the fourth, optional field follows...
% \category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

% \terms{Theory}

\keywords{logic, coq, idris} % NOT required for Proceedings

% \section{Introduction}
% Sample text. Sample text. Sample text. Sample text. Sample text. Sample text. 
% Sample text. Sample text. Sample text. Sample text. Sample text. Sample text. 
% Sample text. Sample text. Sample text. Sample text. Sample text. Sample text. 
% Sample text. Sample text. Sample text. Sample text. Sample text. Sample text. 
% Sample text. Sample text. Sample text. Sample text. Sample text. Sample text. 
% Sample text. Sample text. Sample text. Sample text. Sample text. Sample text. 
% Sample text. Sample text. Sample text. Sample text. Sample text. Sample text. 

% Citation of Einstein paper~\cite{Einstein}.

% \section{Results and Discussions}
% Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

% Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

% Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

% Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

% \bibliographystyle{abbrv}
% \bibliography{sample}

\begin{minted}[]{idris}
||| An Idris port of Coq.Init.Logic
module Logic

import Data.Bifunctor

%access export
\end{minted}

\section{Propositional connectives}\label{propositional-connectives}

\subsection{Unit}\label{unit}

\mintinline[]{idris}{()} is the always true proposition (\(\top\)).

\begin{minted}[]{idris}
%elim data Unit = MkUnit
\end{minted}

\subsection{Void}\label{void}

\mintinline[]{idris}{Void} is the always false proposition (\(\bot\)).

\begin{minted}[]{idris}
%elim data Void : Type where
\end{minted}

\subsection{Negation}\label{negation}

\mintinline[]{idris}{Not a}, written \mintinline[]{idris}{~a}, is the
negation of \mintinline[]{idris}{a}.

\begin{minted}[]{idris}
syntax "~" [x] = (Not x)
\end{minted}

\begin{minted}[]{idris}
Not : Type -> Type
Not a = a -> Void
\end{minted}

\subsection{Conjunction}\label{conjunction}

\mintinline[]{idris}{And a b}, written \mintinline[]{idris}{(a, b)}, is
the conjunction of \mintinline[]{idris}{a} and \mintinline[]{idris}{b}.

\mintinline[]{idris}{Conj p q} is a proof of
\mintinline[]{idris}{(a, b)} as soon as \mintinline[]{idris}{p} is a
proof of \mintinline[]{idris}{a} and \mintinline[]{idris}{q} a proof of
\mintinline[]{idris}{b}.

\mintinline[]{idris}{proj1} and \mintinline[]{idris}{proj2} are first
and second projections of a conjunction.

\begin{minted}[]{idris}
syntax "(" [a] "," [b] ")" = (And a b)

||| The conjunction of `a` and `b`.
data And : Type -> Type -> Type where
     Conj : a -> b -> (a, b)

implementation Bifunctor And where
    bimap f g (Conj a b) = Conj (f a) (g b)

||| First projection of a conjunction.
proj1 : (a, b) -> a
proj1 (Conj a _) = a

||| Second projection of a conjunction.
proj2 : (a, b) -> b
proj2 (Conj _ b) = b
\end{minted}

\subsection{Disjunction}\label{disjunction}

\mintinline[]{idris}{Either a b} is the disjunction of
\mintinline[]{idris}{a} and \mintinline[]{idris}{b}.

\begin{minted}[]{idris}
data Either : Type -> Type -> Type where
     Left   : a -> Either a b
     Right  : b -> Either a b     
\end{minted}

\newpage

\subsection{Biconditional}\label{biconditional}

\href{https://proofwiki.org/wiki/Definition:Biconditional}{Proof Wiki}

\(\varphi \vdash \psi\)\\
\(\underline{\psi \vdash \varphi}\)\\
\(\varphi \iff \psi\)

\mintinline[]{idris}{iff a b}, written \mintinline[]{idris}{a <-> b},
expresses the equivalence of \mintinline[]{idris}{a} and
\mintinline[]{idris}{b}.

\begin{minted}[]{idris}
infixl 9 <->

||| The biconditional is a *binary connective* that
||| can be voiced: *p* **if and only if** *q*.
public export
(<->) : Type -> Type -> Type
(<->) a b = (a -> b, b -> a)
\end{minted}

\subsubsection{Biconditional is
Reflexive}\label{biconditional-is-reflexive}

\href{https://proofwiki.org/wiki/Biconditional_is_Reflexive}{Proof Wiki}

\(\vdash \varphi \iff \varphi\)

\begin{minted}[]{idris}
||| The biconditional operator is reflexive.
iffRefl : a <-> a
iffRefl = Conj id id
\end{minted}

\subsubsection{Biconditional is
Transitive}\label{biconditional-is-transitive}

\href{https://proofwiki.org/wiki/Biconditional_is_Transitive}{Proof
Wiki}

\[
  \begin{prooftree}
    \Hypo{ \varphi \iff \psi }
    \Hypo{ \psi \iff \chi }
    \Infer2 { \vdash \varphi \iff \chi }
  \end{prooftree}
\]

\begin{minted}[]{idris}
||| The biconditional operator is transitive.
iffTrans : (a <-> b) -> (b <-> c) -> (a <-> c)
iffTrans (Conj ab ba) (Conj bc cb) =
    Conj (bc . ab) (ba . cb)
\end{minted}

\subsubsection{Biconditional is
Commutative}\label{biconditional-is-commutative}

\href{https://proofwiki.org/wiki/Biconditional_is_Commutative}{Proof
Wiki}

\(\varphi \iff \psi \dashv\vdash \psi \iff \varphi\)

or

\(\vdash (\varphi \iff \psi) \iff (\psi \iff \varphi)\)

\begin{minted}[]{idris}
||| The biconditional operator is commutative.
iffSym : (a <-> b) -> (b <-> a)
iffSym (Conj ab ba) = Conj ba ab
\end{minted}

\subsubsection{andIffCompatLeft}\label{andiffcompatleft}

\(\psi \iff \chi \dashv\vdash (\varphi \land \psi) \iff (\varphi \land \chi)\)

\begin{minted}[]{idris}
andIffCompatLeft : (b <-> c) -> ((a, b) <-> (a, c))
andIffCompatLeft = bimap second second
\end{minted}

\subsubsection{andIffCompatRight}\label{andiffcompatright}

\(\psi \iff \chi \dashv\vdash (\psi \land \varphi) \iff (\chi \land \varphi)\)

\begin{minted}[]{idris}
andIffCompatRight : (b <-> c) -> ((b, a) <-> (c, a))
andIffCompatRight = bimap first first
\end{minted}

\subsubsection{orIffCompatLeft}\label{oriffcompatleft}

\(\psi \iff \chi \vdash (\varphi \lor \psi) \iff (\varphi \lor \chi)\)

\begin{minted}[]{idris}
orIffCompatLeft : (b <-> c) ->
                  (Either a b <-> Either a c)
orIffCompatLeft = bimap second second
\end{minted}

\subsubsection{orIffCompatRight}\label{oriffcompatright}

\(\psi \iff \chi \vdash (\psi \lor \varphi) \iff (\chi \lor \varphi)\)

\begin{minted}[]{idris}
orIffCompatRight : (b <-> c) ->
                   (Either b a <-> Either c a)
orIffCompatRight = bimap first first
\end{minted}

\subsubsection{negVoid}\label{negvoid}

\(\neg \varphi \dashv\vdash \varphi \iff \bot\)

or

\(\vdash \neg \varphi \iff (\varphi \iff \bot)\)

\begin{minted}[]{idris}
negVoid : (~a) <-> (a <-> Void)
negVoid = Conj (flip Conj void) proj1
\end{minted}

\subsubsection{andCancelLeft}\label{andcancelleft}

\(\psi \implies \varphi\)\\
\(\underline{\chi \implies \varphi}\)\\
\(((\varphi \land \psi) \iff (\varphi \land \chi)) \iff (\psi \iff \chi)\)

\begin{minted}[]{idris}
andCancelLeft : (b -> a) ->
                (c -> a) ->
                (((a, b) <-> (a, c)) <-> (b <-> c))
andCancelLeft ba ca = Conj (bimap f g) andIffCompatLeft
  where
    f h b = proj2 . h $ Conj (ba b) b
    g h c = proj2 . h $ Conj (ca c) c
\end{minted}

\subsubsection{andCancelRight}\label{andcancelright}

\begin{minted}[]{idris}
andCancelRight : (b -> a) ->
                 (c -> a) ->
                 (((b, a) <-> (c, a)) <-> (b <-> c))
andCancelRight ba ca = Conj (bimap f g) andIffCompatRight
  where
    f h b = proj1 . h $ Conj b (ba b)
    g h c = proj1 . h $ Conj c (ca c)
\end{minted}

\newpage

\subsubsection{Conjunction is
Commutative}\label{conjunction-is-commutative}

\href{https://proofwiki.org/wiki/Rule_of_Commutation/Conjunction}{Proof
Wiki}

\paragraph{Formulation 1}\label{formulation-1}

\(\varphi \land \psi \dashv\vdash \psi \land \varphi\)

\paragraph{Formulation 2}\label{formulation-2}

\(\vdash (\varphi \land \psi) \iff (\psi \land \varphi)\)

\paragraph{Source}\label{source}

\begin{minted}[]{idris}
||| Conjunction is commutative.
andComm : (a, b) <-> (b, a)
andComm = Conj swap swap
  where
    swap : (p, q) -> (q, p)
    swap (Conj p q) = Conj q p
\end{minted}

\subsubsection{Conjunction is
Associative}\label{conjunction-is-associative}

\href{https://proofwiki.org/wiki/Rule_of_Association/Conjunction}{Proof
Wiki}

\paragraph{Formulation 1}\label{formulation-1-1}

\((\varphi \land \psi) \land \chi \dashv\vdash \varphi \land (\psi \land \chi)\)

\paragraph{Formulation 2}\label{formulation-2-1}

\(\vdash ((\varphi \land \psi) \land \chi) \iff (\varphi \land (\psi \land \chi))\)

\paragraph{Source}\label{source-1}

\begin{minted}[]{idris}
||| Conjunction is associative.
andAssoc : ((a, b), c) <-> (a, (b, c))
andAssoc = Conj f g
  where
    f abc@(Conj (Conj a b) c) =
        Conj a (first proj2 abc)
    g abc@(Conj a (Conj b c)) =
        Conj (second proj1 abc) c
\end{minted}

\subsubsection{orCancelLeft}\label{orcancelleft}

\((\psi \implies \neg \varphi) \implies (\chi \implies \neg \varphi) \implies (((\varphi \lor \psi) \iff (\varphi \lor \chi)) \iff (\psi \iff \chi))\)

\begin{minted}[]{idris}
orCancelLeft : (b -> ~a) ->
               (c -> ~a) ->
               ((Either a b <-> Either a c) <->
                (b <-> c))
orCancelLeft bNotA cNotA =
    Conj (bimap f g) orIffCompatLeft
  where
    f ef b = go (bNotA b) (ef (Right b))
    g eg c = go (cNotA c) (eg (Right c))
    go : (~a) -> Either a b -> b
    go lf = either (void . lf) id
\end{minted}

\newpage

\subsubsection{orCancelRight}\label{orcancelright}

\(\psi \vdash \neg \varphi\)\\
\(\underline{\chi \vdash \neg \varphi}\)\\
\(((\psi \lor \varphi) \iff (\chi \lor \varphi)) \iff (\psi \iff \chi)\)

\begin{minted}[]{idris}
orCancelRight : (b -> ~a) ->
                (c -> ~a) ->
                ((Either b a <-> Either c a) <->
                 (b <-> c))
orCancelRight bNotA cNotA =
    Conj (bimap f g) orIffCompatRight
  where
    f ef b = go (bNotA b) (ef (Left b))
    g eg c = go (cNotA c) (eg (Left c))
    go : (~p) -> Either q p -> q
    go rf = either id (void . rf)
\end{minted}

\subsubsection{Disjunction is
Commutative}\label{disjunction-is-commutative}

\href{https://proofwiki.org/wiki/Rule_of_Commutation/Disjunction}{Proof
Wiki}

\((\varphi \lor \psi) \iff (\psi \lor \varphi)\)

\begin{minted}[]{idris}
||| Disjunction is commutative.
orComm : Either a b <-> Either b a
orComm = Conj mirror mirror
\end{minted}

\subsubsection{Disjunction is
Associative}\label{disjunction-is-associative}

\href{https://proofwiki.org/wiki/Rule_of_Association/Disjunction}{Proof
Wiki}

\((\varphi \lor \psi) \lor \chi \vdash \varphi \lor (\psi \lor \chi)\)

\begin{minted}[]{idris}
||| Disjunction is associative on the left.
orAssocLeft : Either (Either a b) c ->
              Either a (Either b c)
orAssocLeft = either (second Left) (pure . pure)
\end{minted}

\(\varphi \lor (\psi \lor \chi) \vdash (\varphi \lor \psi) \lor \chi\)

\begin{minted}[]{idris}
||| Disjunction is associative on the right.
orAssocRight : Either a (Either b c) ->
               Either (Either a b) c
orAssocRight = either (Left . Left) (first Right)
\end{minted}

\paragraph{Formulation 1}\label{formulation-1-2}

\((\varphi \lor \psi) \lor \chi \dashv\vdash \varphi \lor (\psi \lor \chi)\)

\paragraph{Formulation 2}\label{formulation-2-2}

\(\vdash ((\varphi \lor \psi) \lor \chi) \iff (\varphi \lor (\psi \lor \chi))\)

\paragraph{Source}\label{source-2}

\begin{minted}[]{idris}
||| Disjunction is associative.
orAssoc : Either (Either a b) c <->
          Either a (Either b c)
orAssoc = Conj orAssocLeft orAssocRight
\end{minted}

\newpage

\subsubsection{iffAnd}\label{iffand}

\(\varphi \iff \psi \vdash (\varphi \implies \psi) \land (\psi \implies \varphi)\)

\begin{minted}[]{idris}
iffAnd : (a <-> b) -> (a -> b, b -> a)
iffAnd = id
\end{minted}

\subsubsection{iffAndTo}\label{iffandto}

\(\varphi \iff \psi \dashv\vdash (\varphi \implies \psi) \land (\psi \implies \varphi)\)

or

\(\vdash (\varphi \iff \psi) \iff ((\varphi \implies \psi) \land (\psi \implies \varphi))\)

\begin{minted}[]{idris}
iffToAnd : (a <-> b) <-> (a -> b, b -> a)
iffToAnd = Conj id id
\end{minted}

\balancecolumns

\end{document}
